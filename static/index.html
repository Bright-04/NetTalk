<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Terminal Chat</title>
		<link rel="icon" type="image/svg+xml" href="/static/terminal-favicon.svg" />
		<!-- PNG fallback for browsers that don't support SVG favicons -->
		<link
			rel="icon"
			type="image/png"
			href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAAB49l8LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH5QkFAyQ6mJ7ZLQAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAAzElEQVRIx+2WsQ3CMBBF3yQk0gLqgk6g5yFXoTtYg2g2g2k2QY2k3QY2g3LQxGJmXGJ3b3c8z7n3k8B/6oG8u5lQ9xwAAf4Avc8gPB8gWk6q2iw6wIsei0WJmJ9A3gF4wE0wDngM3gJ9gF4wF0wBngM3gJ9gF4wE0wDngM3gJ9gF4wF0wBngM3gJ9gF4wE0wDngM3gJ9gF4wF0wBngM3gJ9j3bA+I6x7jqwqQGmQAAAABJRU5ErkJggg=="
		/>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
			}
			body {
				background: #000;
				color: #b6f36b;
				font-family: Menlo, Consolas, monospace;
			}
			.wrap {
				display: flex;
				flex-direction: column;
				height: 100vh;
				padding: 10px;
				box-sizing: border-box;
			}
			#terminal {
				flex: 1;
				overflow: auto;
				white-space: pre-wrap;
				word-break: break-word; /* allow long words/URLs to wrap */
				/* Make the scrollbar visually match the terminal style */
				-ms-overflow-style: none; /* hide default scrollbar in IE/Edge (shows none but still scrollable) */
				scrollbar-width: thin; /* Firefox: make scrollbar thin */
				scrollbar-color: rgba(182, 243, 107, 0.14) transparent; /* Firefox: thumb and track */
			}
			/* WebKit browsers (Chrome, Safari) custom scrollbar styling */
			#terminal::-webkit-scrollbar {
				width: 10px;
				height: 10px;
			}
			#terminal::-webkit-scrollbar-track {
				background: transparent;
			}
			#terminal::-webkit-scrollbar-thumb {
				background: rgba(182, 243, 107, 0.12);
				border-radius: 8px;
				border: 1px solid rgba(0, 0, 0, 0.55);
			}
			#terminal::-webkit-scrollbar-thumb:hover {
				background: rgba(182, 243, 107, 0.2);
			}
			#users-panel {
				position: absolute;
				top: 12px;
				right: 12px;
				background: rgba(0, 0, 0, 0.6);
				border: 1px solid #333;
				color: #b6f36b;
				padding: 8px;
				font-family: inherit;
				font-size: 13px;
				max-width: 240px;
				max-height: 60vh;
				overflow: auto;
				/* match terminal scrollbar appearance */
				-ms-overflow-style: none;
				scrollbar-width: thin;
				scrollbar-color: rgba(182, 243, 107, 0.12) transparent;
				box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
			}
			#users-panel::-webkit-scrollbar {
				width: 8px;
				height: 8px;
			}
			#users-panel::-webkit-scrollbar-track {
				background: transparent;
			}
			#users-panel::-webkit-scrollbar-thumb {
				background: rgba(182, 243, 107, 0.12);
				border-radius: 6px;
				border: 1px solid rgba(0, 0, 0, 0.55);
			}
			#users-panel h4 {
				margin: 0 0 6px 0;
				font-size: 12px;
				color: #6ef;
			}
			#users-panel ul {
				list-style: none;
				padding: 0;
				margin: 0;
			}
			#users-panel li {
				padding: 2px 0;
				border-bottom: 1px dashed rgba(255, 255, 255, 0.03);
				font-size: 12px;
			}
			.input-row {
				display: flex;
				gap: 8px;
				margin-top: 8px;
			}
			#prompt {
				display: none;
				min-width: 0;
				color: #6ef;
			}
			/* distinct style when asking for display name */
			#prompt.name-mode {
				display: inline-block;
				background: #071;
				border: 1px solid #264;
				color: #b6f36b;
				padding: 4px 8px;
				border-radius: 4px;
				font-weight: 700;
			}

			/* quote shown at the top while entering display name */
			.name-quote-top {
				display: none;
				position: absolute;
				top: 18px;
				left: 18px; /* align left per request */
				transform: none;
				max-width: calc(100% - 36px);
				color: #9ad0ff;
				font-style: italic;
				font-size: 15px;
				border-left: 4px solid rgba(106, 192, 255, 0.18);
				padding-left: 12px;
				padding-top: 6px;
				padding-bottom: 6px;
				background: rgba(0, 0, 0, 0.35);
				backdrop-filter: blur(2px);
				border-radius: 6px;
				z-index: 20;
			}

			/* visible when prompt is in name-mode */
			.name-quote-top.visible {
				display: block;
			}

			/* input appearance when entering name to make it clearly different */
			#cmd.name-input {
				background: #011;
				border: 1px solid #234;
				color: #b6f36b;
				font-weight: 600;
			}
			#cmd {
				flex: 1;
				background: #000;
				border: 1px solid #333;
				color: inherit;
				padding: 6px;
				font-family: inherit;
				font-size: 14px;
			}
			.meta {
				color: #888;
				font-size: 12px;
			}
			/* notification text (join/leave) */
			.notice {
				color: #777; /* slightly dimmer gray for notifications */
				font-style: italic;
			}
			.meta.rate {
				color: #f66; /* red-ish */
				font-weight: 600;
			}
			.line .from {
				color: #6ef;
				white-space: nowrap;
			}
			.line .ip {
				color: #8fb;
				margin-left: 6px;
				font-size: 12px;
			}
			.line .time {
				color: #777;
				margin-left: 6px;
				font-size: 12px;
			}
		</style>
	</head>
	<body>
		<div class="wrap">
			<!-- quote shown when entering display name (top of UI) -->
			<div id="name-quote-top" class="name-quote-top" aria-hidden="true"></div>
			<div id="terminal"></div>
			<!-- users panel: small, terminal-styled list of online users -->
			<div id="users-panel" aria-live="polite"></div>
			<div class="input-row">
				<div id="prompt">you@lan</div>
				<input id="cmd" autocomplete="off" autofocus placeholder="Type message and press Enter" />
			</div>
		</div>

		<script>
			const terminal = document.getElementById("terminal");
			const cmd = document.getElementById("cmd");
			let username = "";

			// DOM-safe helpers
			function appendLineNode(children, className = "line") {
				const div = document.createElement("div");
				div.className = className;
				children.forEach((node) => div.appendChild(node));
				terminal.appendChild(div);
				terminal.scrollTop = terminal.scrollHeight;
			}

			// users panel helpers
			const usersPanel = document.getElementById("users-panel");
			function renderUsersList(users) {
				// users: array of {name, ip}
				if (!usersPanel) return;
				usersPanel.innerHTML = "";
				const h = document.createElement("h4");
				h.appendChild(textNode("Online users"));
				usersPanel.appendChild(h);
				const ul = document.createElement("ul");
				users.forEach((u) => {
					const li = document.createElement("li");
					const nameLabel = u.name || "Unknown";
					// name span with per-user color
					const nameSpan = document.createElement("span");
					nameSpan.textContent = nameLabel;
					nameSpan.style.color = colorForName(nameLabel);
					li.appendChild(nameSpan);
					if (u.ip) {
						const ipEl = document.createElement("span");
						ipEl.className = "ip";
						ipEl.textContent = " [" + u.ip + "]";
						li.appendChild(ipEl);
					}
					if (u.name === username) {
						const you = document.createElement("span");
						you.textContent = " (you)";
						you.className = "meta";
						li.appendChild(you);
					}
					ul.appendChild(li);
				});
				usersPanel.appendChild(ul);
			}

			function textNode(text) {
				return document.createTextNode(text);
			}

			function metaNode(text) {
				const span = document.createElement("span");
				span.className = "meta";
				span.appendChild(textNode(text));
				return span;
			}

			function nameNode(name) {
				const s = document.createElement("span");
				s.appendChild(textNode(name));
				s.className = "from";
				// apply deterministic color per username for consistent display
				s.style.color = colorForName(name);
				return s;
			}

			// Deterministic color generator based on a simple hash of the name.
			// Produces readable HSL colors on dark backgrounds.
			function colorForName(name) {
				if (!name) return "#b6f36b";
				// djb2 hash
				let hash = 5381;
				for (let i = 0; i < name.length; i++) {
					hash = (hash << 5) + hash + name.charCodeAt(i);
					// keep in 32-bit range
					hash = hash & 0xffffffff;
				}
				const hue = Math.abs(hash) % 360;
				const saturation = 60; // percent
				const lightness = 60; // percent - bright enough on dark bg
				// use comma-separated HSL syntax for broader browser compatibility
				return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
			}

			function messageTextNode(name, text) {
				const span = document.createElement("span");
				span.textContent = text;
				// keep punctuation/meta parts slightly dimmer by using the same hue but lower lightness
				try {
					span.style.color = colorForName(name);
				} catch (e) {
					span.style.color = "#b6f36b";
				}
				return span;
			}

			function noticeNode(text) {
				const span = document.createElement("span");
				span.className = "notice";
				span.appendChild(textNode(text));
				return span;
			}

			function ipNode(ip) {
				const s = document.createElement("span");
				s.className = "ip";
				// render with surrounding brackets and a leading space so it reads
				// like: "You [192.168.1.23]"
				s.appendChild(textNode(" [" + ip + "]"));
				return s;
			}

			function appendMetaText(text) {
				appendLineNode([metaNode(text)]);
			}

			function rateNode(text) {
				const span = document.createElement("span");
				span.className = "meta rate";
				span.appendChild(textNode(text));
				return span;
			}

			function appendRateNotice(text) {
				appendLineNode([rateNode(text)]);
			}

			function timeNow() {
				const d = new Date();
				return d.toLocaleTimeString();
			}

			// WebSocket with reconnect/backoff
			(function () {
				// Use an in-terminal prompt instead of browser modal prompt()
				let awaitingName = true;
				// show the prompt area visually and set placeholder to ask for name
				const promptEl = document.getElementById("prompt");
				// visually switch to name-entry mode (no literal 'enter name@lan' text)
				promptEl.classList.add("name-mode");
				promptEl.textContent = "";
				cmd.classList.add("name-input");
				cmd.placeholder = "Enter display name and press Enter";
				cmd.focus();

				// Typing quote logic: word-by-word typing at the top
				const quoteEl = document.getElementById("name-quote-top");
				const quotes = ["Wake up, Neo...", "I know you're out there. I can feel you now. I know that you're afraid. You're afraid of us. You're afraid of change."];
				let quoteIndex = 0;
				let quoteWords = [];
				let typingTimer = null;
				let currentIndex = 0;

				function startTyping() {
					if (!quoteEl) return;
					quoteEl.classList.add("visible");
					// begin with the first quote
					quoteIndex = 0;
					startQuote(quoteIndex);
				}

				function startQuote(i) {
					if (!quoteEl) return;
					quoteEl.textContent = "";
					quoteWords = quotes[i].split(/\s+/);
					currentIndex = 0;
					step();
				}

				function stopTyping() {
					if (!quoteEl) return;
					quoteEl.classList.remove("visible");
					quoteEl.textContent = "";
					if (typingTimer) {
						clearTimeout(typingTimer);
						typingTimer = null;
					}
				}

				function step() {
					if (currentIndex >= quoteWords.length) {
						// finished current quote
						typingTimer = null;
						quoteIndex++;
						if (quoteIndex < quotes.length) {
							// pause then start next quote
							typingTimer = setTimeout(() => startQuote(quoteIndex), 900);
						} else {
							// all quotes done; keep displayed until name entered
						}
						return;
					}
					const w = quoteWords[currentIndex];
					quoteEl.textContent += (currentIndex ? " " : "") + w;
					currentIndex++;
					// variable delay: slightly longer after punctuation
					let delay = 220 + Math.floor(Math.random() * 80);
					if (/[.!?]$/.test(w)) delay += 260;
					typingTimer = setTimeout(step, delay);
				}

				// Observe class changes on the prompt to start/stop typing
				const obs = new MutationObserver((mutations) => {
					for (const m of mutations) {
						if (m.type === "attributes" && m.attributeName === "class") {
							const has = promptEl.classList.contains("name-mode");
							if (has) startTyping();
							else stopTyping();
						}
					}
				});
				obs.observe(promptEl, { attributes: true });
				// start immediately if name-mode already present
				if (promptEl.classList.contains("name-mode")) startTyping();

				const proto = location.protocol === "https:" ? "wss" : "ws";
				const wsUrl = proto + "://" + location.host + "/ws";

				let ws = null;
				let backoff = 1;
				let maxBackoff = 30;

				function connect() {
					ws = new WebSocket(wsUrl);

					ws.addEventListener("open", () => {
						appendMetaText("[connected to server]");
						backoff = 1;
						try {
							ws.send(JSON.stringify({ type: "join", username }));
						} catch (e) {
							console.error("join send failed", e);
						}
					});

					ws.addEventListener("message", (ev) => {
						try {
							const m = JSON.parse(ev.data);
							if (m.type === "welcome") {
								username = m.username || username;
								document.getElementById("prompt").textContent = username + "@lan";
								return;
							}
							if (m.type === "users" && Array.isArray(m.users)) {
								// update users panel with the authoritative list from server
								renderUsersList(m.users);
								return;
							}
							if (m.type === "rate_limited") {
								const retry = m.retry_after || 1;
								appendRateNotice(`[rate-limited] slow down \u2014 retry in ${retry}s`);
								return;
							}
							if (m.type === "too_many_logins") {
								appendRateNotice(`[connection refused] too many connections from your IP (limit ${m.limit})`);
								return;
							}
							if (m.type === "join") {
								const time = "[" + timeNow() + "] ";
								const nodes = [metaNode(time), nameNode(m.from)];
								if (m.ip) nodes.push(ipNode(m.ip));
								nodes.push(noticeNode(" joined the chat"));
								appendLineNode(nodes);
							} else if (m.type === "leave") {
								const time = "[" + timeNow() + "] ";
								const nodes = [metaNode(time), nameNode(m.from)];
								if (m.ip) nodes.push(ipNode(m.ip));
								nodes.push(noticeNode(" left"));
								appendLineNode(nodes);
							} else if (m.type === "message") {
								const time = "[" + timeNow() + "] ";
								// show timestamp first (like join/leave)
								const nodes = [metaNode(time), nameNode(m.from)];
								if (m.ip) nodes.push(ipNode(m.ip));
								// message text should use the same color as the sender
								nodes.push(messageTextNode(m.from, ": " + (m.text || "")));
								appendLineNode(nodes);
							}
						} catch (e) {
							console.error(e);
						}
					});

					ws.addEventListener("close", (ev) => {
						appendMetaText("[disconnected]");
						scheduleReconnect();
					});
					ws.addEventListener("error", (ev) => {
						appendMetaText("[connection error]");
					});
				}

				function scheduleReconnect() {
					const wait = Math.min(backoff, maxBackoff);
					appendMetaText(`[reconnecting in ${wait}s]`);
					setTimeout(() => {
						backoff = Math.min(maxBackoff, backoff * 1.8 + 1);
						// connect() will be started after the user submits a name
					}, wait * 1000);
				}

				cmd.addEventListener("keydown", (e) => {
					if (e.key !== "Enter") return;
					const text = cmd.value.trim();
					if (!text) return;
					// If we're awaiting the initial name, treat this as the join name
					if (typeof awaitingName !== "undefined" && awaitingName) {
						username = text || "You";
						// remove name-entry visual mode and show normal prompt
						promptEl.classList.remove("name-mode");
						promptEl.textContent = username + "@lan";
						cmd.classList.remove("name-input");
						cmd.placeholder = "Type message and press Enter";
						cmd.value = "";
						awaitingName = false;
						// now start the websocket connection
						connect();
						return;
					}
					// Normal message send flow
					try {
						if (ws && ws.readyState === WebSocket.OPEN) {
							ws.send(JSON.stringify({ type: "message", text }));
						} else {
							appendRateNotice("[offline] message queued temporarily");
						}
					} catch (err) {
						console.error("send failed", err);
					}
					cmd.value = "";
				});
			})();
		</script>
	</body>
</html>
